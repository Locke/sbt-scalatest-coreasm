package de.athalis.sbt.testcoreasm

import sbt.Keys._
import sbt._

object ScalatestCoreASMPlugin extends AutoPlugin {
  override def requires = plugins.JvmPlugin

  object autoImport {
    lazy val TestCoreASM = config("test-coreasm") extend (Test)

    lazy val generateCoreASMTests = taskKey[Seq[File]]("generate scalatest classes for CoreASM specifications")
    lazy val testCoreASMPackageName = settingKey[String]("package name for the generated scalatest classes")
  }

  import autoImport._

  lazy val baseTestCoreASMSettings = Def.settings(
    testCoreASMPackageName := "de.athalis.sbt.testcoreasm.generated",

    sourceDirectory := (sourceDirectory in Test).value / "coreasm",
    sourceManaged := (sourceManaged in Test).value / "coreasm",

    includeFilter := ("*.casm" || "*.coreasm"),
    excludeFilter := HiddenFileFilter,

    sources := (sourceDirectory.value ** (includeFilter.value -- excludeFilter.value)).get,

    generateCoreASMTests := {
      val log = streams.value.log
      val cachedFun = FileFunction.cached(streams.value.cacheDirectory, FilesInfo.lastModified, FilesInfo.lastModified) {
        (in: Set[File]) =>
          Generator(testCoreASMPackageName.value, sourceDirectory.value, in, sourceManaged.value, log) : Set[File]
      }
      cachedFun(sources.value.toSet).toSeq
    }
  )

  override lazy val projectSettings =
    inConfig(TestCoreASM)(baseTestCoreASMSettings) ++
    Def.settings(
      libraryDependencies ++= Seq("de.athalis" %% "sbt-scalatest-coreasm-lib" % BuildInfo.version % "test"),

      // fork is necessary as the Engine only writes to System.out
      fork in Test := true,

      sourceGenerators in Test += (generateCoreASMTests in TestCoreASM),
      managedSourceDirectories in Test += (sourceManaged in TestCoreASM).value,
      unmanagedResourceDirectories in Test += (sourceDirectory in TestCoreASM).value,
      cleanFiles += (sourceManaged in TestCoreASM).value
    )
}

object Generator {
  private val info = "%s, version: %s, scalaVersion: %s, sbtVersion: %s" format (BuildInfo.name, BuildInfo.version, BuildInfo.scalaVersion, BuildInfo.sbtVersion)

  private val template = 
"""package %s

/*
This file is automatically generated by %s.
Do not modify this file -- YOUR CHANGES WILL BE ERASED!
*/

import java.io.{InputStreamReader, Reader}

class %s extends de.athalis.sbt.testcoreasm.TestAllCasm {
  def testFileNames: Seq[String] = %s
  def getTestFileReader(testFileName: String): Reader = new InputStreamReader(this.getClass.getClassLoader.getResource(testFileName).openStream())
}
"""

  def apply(packageName: String, srcDirIn: File, filesIn: Set[File], outDirIn: File, log: Logger): Set[File] = {
    val srcDir: File = srcDirIn.getCanonicalFile
    val files: Set[File] = filesIn.map(_.getCanonicalFile)
    val outDir: File = outDirIn.getCanonicalFile

    log.info("ScalatestCoreASMPlugin: generating test files..")
    log.debug("srcDir: " + srcDir)
    log.debug("files: " + files)
    log.debug("outDir: " + outDir)

    val testNamesWithRelativeFiles: Map[String, Set[File]] = toRelativeMap(srcDir, files)

    log.debug("testNamesWithRelativeFiles: " + testNamesWithRelativeFiles)

    val generatedFiles: Set[File] = testNamesWithRelativeFiles.map(x => {
        val testName = x._1
        val relativeFiles = x._2

        generate(packageName, relativeFiles, outDir, testName)
      }).toSet.flatten

    log.debug("generatedFiles: " + generatedFiles)

    generatedFiles
  }

  private def toRelativeMap(srcDir: File, files: Set[File]): Map[String, Set[File]] = {
    val filesWithTestName: Set[(File, String)] = files.map(f => {
        val testName: String = if (f.getParentFile.equals(srcDir)) {
          "WithoutTestClasses"
        }
        else {
          f.getParentFile.getName
        }

        (f, testName)
      })

    val testNames: Set[String] = filesWithTestName.map(_._2)

    val testNamesWithRelativeFiles: Map[String, Set[File]] = testNames.map(key => {
        val files: Set[File] = filesWithTestName.filter(_._2 == key).map(_._1)

        val relativeFiles: Set[File] = files.map(f => {
          srcDir.relativize(f) match {
            case Some(fRelative) => fRelative
            case None => throw new IllegalArgumentException("source file '%s' is not in srcDir '%s'".format(f, srcDir))
          }
        })

        (key, relativeFiles)
      }).toMap

    testNamesWithRelativeFiles
  }

  private def generate(packageName: String, relativeFiles: Set[File], outDir: File, testName: String): Set[File] = {
    val filesString = relativeFiles.map(f => f.getPath)

    val filesSeqString = filesString.mkString("Seq(\"", "\", \"", "\")")

    val source = template format (packageName, info, "Test" + testName, filesSeqString)

    val outFile = outDir / ("Test" + testName + ".scala")
    IO.write(outFile, source)

    Set(outFile)
  }
}

